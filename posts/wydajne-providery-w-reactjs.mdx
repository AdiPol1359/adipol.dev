---
date: '2023-11-11'
title: Wydajne providery w React.js 
introduction: Context API to jedna z podstawowych funkcjonalnoci w Reacie. Dogbne poznanie dziaania provider'贸w pozwoli pisa Ci bardziej wiadomy, oraz wydajny kod, co w konsekwencji przeo偶y si na optymalizacj Twojej aplikacji. W tym artykule dowiesz si o najczciej popenianych bdach, szczeg贸lnie wsr贸d pocztkujcych programist贸w, podczas korzystania z kontekst贸w.
thumbnail:
  path: /thumbnails/wydajne-providery-w-reactjs.png
  width: 1200
  height: 630
tags:
  - React
---

Providery w Reacie tozdecydowanie jedna z najistotniejszych rzeczy przy budowaniu aplikacji webowych. To wanie z ich pomoc raz na zawsze zakoczylimy bolczk w postaci przesyania X razy props贸w w d贸 do naszych dzieci, 偶eby dzieli stan midzy sob. Pomimo tego, 偶e context API znacznie uatwia nam zarzdzanie globalnym stanem, pomagajc jednoczenie przy codziennej pracy, musimy by czujni i uwa偶a na puapki, kt贸re mog negatywnie wpyn na wydajno naszej strony. Dlatego w tym artykule chciabym Ci przestrze przed najczciej popenianymi bdami podczas u偶ywania provider贸w, kt贸re spotykam szczeg贸lnie wr贸d pocztkujcych programist贸w, zaczynajcych dopiero swoj przygod z Reactem. Mam nadziej, 偶e po przeczytaniu tego posta lepiej zrozumiesz w jaki spos贸b dziaa share'owanie stanu w Reacie, co pozwoli pisa Ci to bardziej wiadomy, oraz wydajny kod. Zapraszam do lektury .

## Jak dzieli stan pomidzy komponentami?

Proponuj zacz od kr贸tkiego przypomnienia, w jaki spos贸b tworzymy providery w Reacie:

```ts:App.tsx
export const ThemeContext = createContext<'dark' | 'light'>('dark');

export const App = () => (
  <ThemeContext.Provider value={'dark'}>
    <Theme />
  </ThemeContext.Provider>
)
```

```ts:Theme.tsx
export const Theme = () => {
  const theme = useContext(ThemeContext);

  return <p>Current theme: <strong>{theme}</strong></p>;
}
```

Na pocztku stworzylimy `ThemeContext` za pomocfunkcji `createContext`, zaimportowanej z Reacta. Do rodka przekazalimy **domyln warto**, kt贸ra zostanie u偶yta na wypadek, gdy React **nie znajdzie 偶adnego providera w drzewie komponent贸w rodzic贸w**. Nastpnie w g贸wnym komponencie `App` wyrenderowalimy `ThemeContext.Provider`, kt贸ry **dostarczy przekazanwarto `value` do swoich dzieci**. Finalnie zostao nam ju偶 tylko odczytawarto z contextu za pomochooka `useContext`. No i to tyle, wanie udao nam si przekaza stan do swoich dzieci. Kod dziaa, a my mo偶emy rozej si do domu. Providery w Reacie wydaj si na tyle proste i logiczne, 偶e przecie偶 nic zego nie mo偶e si tutaj wydarzy - ale czy na pewno? P贸jd藕my o krok dalej i rozbudujmy troch ten przykad.

## Task z jiry

Zderzmy si z rzeczywistym problemem, kt贸ry mo偶emy napotka przy codziennej pracy z Reactem. Powiedzmy, 偶e dostalimy taska na jirze, w kt贸rym musimy zaimplementowa **dark theme** oraz **system logowania**. W opisie zadania jasno postawiono nam wymogi, 偶e zar贸wno theme, jak i zalogowany user **powinien by atwo dostpny z poziomu ka偶dego komponentu**. Do gowy od razu przychodzi nam context API. Zabieramy si wic do pracy.

Idc po najni偶szej linii oporu, pierwsza wersja naszego zadania mogaby wyglda mniej wicej w taki spos贸b:

<iframe
	src="https://codesandbox.io/embed/wydajne-providery-w-reactjs-1-rq879q?expanddevtools=1&fontsize=14&hidenavigation=1&module=%2Fsrc%2FApp.tsx&theme=dark"
	style={{
		width: '100%',
		height: '500px',
		border: 0,
		borderRadius: '4px',
		overflow: 'hidden',
	}}
	title="wydajne-providery-w-reactjs-1"
	allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
	sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

Na pierwszy rzut oka wszystko dziaa, a my czujemy, 偶e mo偶emy zamkn taska, wrzuci brancha na code review i by z siebie dumnyi, 偶e podoalimy kolejnemu ci偶kiemu zadaniu w robocie. Przyjrzyjmy si temu bli偶ej.

Dzielony stan pomidzy komponentami zdefiniowalimy **bezporednio w komponencie `App`**, czyli **g贸wnym komponencie naszej aplikacji**. Jest to pierwszy, **bardzo czsty bd popeniany przez pocztkujcych programist贸w**. Nie ma co si dziwi, bo wydaje si to dosy logiczne i intucyjne, 偶eby dzielony stan wrzuci na sam g贸r naszej aplikacji. Spowoduje to natomiast pewne problemy. Przede wszystkim, z perspektywy czytelnoci kodu, **nie jest to najlepsze podejcie**, bo w przyszoci, gdy do naszej aplikacji dojd jeszcze dwa globalne stany, plik `App.tsx` **uronie i nie bdzie dao si go przeczyta**. Ja natomiast chciabym skupi si na drugej, troch powa偶niejszej konsekwencji tego bdu.

U偶ywajc wartoci z globalnego stanu w komponencie oczekujemy od niej, 偶e gdy ta **ulegnie zmianie**, nasz komponent **r贸wnie偶 si przerenderuje wraz z najnowszymi danymi**. Jak React sobie z tym radzi? Ka偶dy komponent, kt贸ry u偶ywa w sobie hooka `useContext` **zostanie automatycznie przerenderowany**, gdy zmieni si warto `value` pochodzca z naszego providera. No wanie - powinny przerenderowa si **tylko** komponenty u偶ywajce hooka `useContext`, czy tak si u nas dzieje?

<Image
	src="/posts/wydajne-providery-w-reactjs/preview-1.gif"
	alt="Podgld 1"
	width={1680}
	height={1050}
/>

Zauwa偶, 偶e zmieniajc wartostanu `theme`, pochodzcego z `ThemeContext.Provider`, **przerenderowywuj si wszystkie komponenty**, a nie tylko te, **kt贸re wykorzystuj hooka `useContext`**. Dlaczego tak si dzieje? Zerknijmy na plik `App.tsx`:

```ts:App.tsx
export const App = () => {
  const [theme, setTheme] = useState<Theme>("dark");
  const [user, setUser] = useState<User>({
    id: 1,
    email: "foo@gmail.com",
  });

  const changeTheme = (theme: Theme) => setTheme(theme);
  const changeUser = (user: User) => setUser(user);

  return (
    <ThemeContext.Provider value={{ theme, changeTheme }}>
      <UserContext.Provider value={{ user, changeUser }}>
        <Header />
        <main style={{ padding: "20px" }}>
          <User />
          <Theme />
        </main>
        <Footer />
      </UserContext.Provider>
    </ThemeContext.Provider>
  );
};
```

Klikajc przycisk `Toggle theme`, wywoujemy funkcj `changeTheme`. Funkcja ta wywouje pod spodem `setTheme`, aby zaktualizowa nasz stan. Tylko musimy pamita, 偶e wywoanie settera z useState spowoduje **ponowne wykonanie funkcji komponentu**, 偶eby ten m贸g otrzyma najnowsze dane.

Dlatego wanie po wywoaniu funkcji `changeTheme`, wywoujemy `setTheme`, co z kolei wywouje funkcj `App`, a poniewa偶 w komponencie `App` wyrenderowalimy komponenty `Header`, `User`, `Theme`, oraz `Footer` - **wszystkie zostanwyrenderowane od nowa** (nie biorc pod uwag memoizacji). Musimy wic pamita, 偶eby nie zagnie偶d偶a komponent贸w naszej aplikacji bezporednio w providerach, bo doprowadzi to do **przerenderowania caej aplikacji od nowa po zmianie jakiegokolwiek stanu**, i przy okazji kompletnie nie korzystamy z optymalizacji, o kt贸rej wczeniej wspomniaem.

Mo偶emy poradzi sobie z tym problemem za pomoc propsa `children`. Zabierzmy si zatem za refaktoryzacj.

## Przeniesienie provider贸w do osobnego pliku

Oczyciem troch plik `App.tsx` **przenoszc logik odpowiedzialn za globalny stan** do osobnego pliku - `AppProviders.tsx`. Zobaczmy jak to si teraz prezentuje:

<iframe
	src="https://codesandbox.io/embed/wydajne-providery-w-reactjs-2-52n96v?expanddevtools=1&fontsize=14&hidenavigation=1&module=%2Fsrc%2Fproviders%2FAppProviders.tsx&theme=dark"
	style={{
		width: '100%',
		height: '500px',
		border: 0,
		borderRadius: '4px',
		overflow: 'hidden',
	}}
	title="wydajne-providery-w-reactjs-2"
	allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
	sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

Patrzc na nasz projekt na pewno miao mo偶emy powiedzie, 偶e **sta si on du偶o czytelniejszy**. Przenoszc kod do pliku `AppProviders.tsx` **nie zamiecamy ju偶 niepotrzebnie komponentu `App`**. Wci偶 nie jest idealnie, ale zawsze jest to jaki krok do przodu . Skontrolujmy rerendery naszych komponent贸w:

<Image
	src="/posts/wydajne-providery-w-reactjs/preview-2.gif"
	alt="Podgld 2"
	width={1680}
	height={1050}
/>

Jest troch lepiej, prawda? Przestalimy ju偶 niepotrzebnie rerenderowakomponenty, kt贸re **nie korzystaj z 偶adnego kontekstu** i tak naprawd **nie maj nawet powodu, 偶eby si ponownie wyrenderowa**. Natomiast zauwa偶yem teraz troch inny problem. Po zmianie wartoci stanu `theme`, React przerenderowywuje **wszystkie komponenty, kt贸re korzystaj z hooka `useContext`**. Dlaczego tak si dzieje?

Tak jak ju偶 wczeniej wspomniaem, React **automatycznie przerenderuje komponent** korzystajcy z hooka `useContext`, gdy **zmieni si warto `value` w providerze**, po to, aby zaktualizowa go o najnowsze dane. No dobra, ale skd React ma wiedzie, 偶e warto ulega zmianie i trzeba ponownie wyrenderowa nasz komponent? Wszystko dzieje si za spraw `Object.is`. React u偶ywa tej metody, aby **por贸wna warto `value` wzgldem poprzedniego i aktualnego rendera**, a nastpnie na podstawie zwr贸conego wyniku zadecyduje, **czy warto ulega zmianie i trzeba przerenderowa komponent**, czy mo偶e jednak **zostawiamy go w spokoju**.

Posiadajc twiedz, skupmy si na komponencie `AppProviders`:

```ts:AppProviders.tsx
export const AppProviders = ({
  children,
}: {
  readonly children: ReactNode;
}) => {
  const [theme, setTheme] = useState<Theme>("dark");
  const [user, setUser] = useState<User>({
    id: 1,
    email: "foo@gmail.com",
  });

  const changeTheme = (theme: Theme) => setTheme(theme);
  const changeUser = (user: User) => setUser(user);

  return (
    <ThemeContext.Provider value={{ theme, changeTheme }}>
      <UserContext.Provider value={{ user, changeUser }}>
        {children}
      </UserContext.Provider>
    </ThemeContext.Provider>
  );
};
```

Znowu wywoujc funkcj `changeTheme`, ta powoduje wywoanie `setTheme`, co z kolei przekada si na ponowne wywoanie funkcji `AppProviders`. Dlatego toggle'ujc stan za pomoc buttona na stronie, **spowoduje to rerender komponentu `AppProviders`**. No spoko, ale jak to si ma do sposobu por贸wnywania wartoci `value`, o kt贸rym wczeniej wspomniaem?

Spojrzmy na t linijk: `<UserContext.Provider value={{ user, changeUser }}>`. Przekazujemy w niej do propsa `value` **obiekt z naszym userem wraz z funkcj do jego zmiany**. Zauwa偶, 偶e w 偶aden spos贸b **nie zapisujemy tego obiektu**. Jest on tworzony **od nowa za ka偶dym razem przy wywoaniu naszej funkcji**, co oznacza, 偶e co render bdzie **posiada on innreferencj**. Zagldajc do [dokumentacji `Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) mo偶emy przeczyta, 偶e obiekty **por贸wnywane sza pomocreferencji**, ju偶 rozumiesz?

Pomimo tego, 偶e **nie zmienilimy 偶adnej wartoci stanu providera `UserContext.Provider`**, przez to, 偶e **zmienia si referencja do obiektu w propsie `value`**, React myli, 偶e **warto w tym providerze r贸wnie偶 ulega zmianie i trzeba przerenderowawszystkie komponenty, kt贸re u偶ywaj kontekstu `UserContext`**. Tak wanie dziaa pod spodem odwie偶anie komponent贸w korzystajcych z kontekst贸w.

To jest drugi pow贸d dla kt贸rego umieszczanie wszystkich provider贸w w jednym komponencie r贸wnie偶 nie jest najlepsz opcj. No dobra, ale czy mo偶emy co z tym zrobi? Spr贸bujmy .

### Dodanie memoizacji

<iframe
	src="https://codesandbox.io/embed/wydajne-providery-w-reactjs-3-nssnc8?expanddevtools=1&fontsize=14&hidenavigation=1&module=%2Fsrc%2Fproviders%2FAppProviders.tsx&theme=dark"
	style={{
		width: '100%',
		height: '500px',
		border: 0,
		borderRadius: '4px',
		overflow: 'hidden',
	}}
	title="wydajne-providery-w-reactjs-3"
	allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
	sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

Nasz komponent `AppProviders` ponownie uleg zmianie. Zaraz przyjrzymy mu si bli偶ej, ale najpierw skontrolujmy rerendery:

<Image
	src="/posts/wydajne-providery-w-reactjs/preview-3.gif"
	alt="Podgld 3"
	width={1680}
	height={1050}
/>

Co widzimy? Od teraz React **przerenderowywuje tylko i wycznie komponenty, w kt贸rych globalny stan faktycznie uleg zmianie**. Jest to zdecydowanie najbardziej optymalne rozwizanie, bo **odwie偶amy tylko to, co rzeczywicie tego potrzebuje**. No dobra, zajrzyjmy do rodka i przeanalizujmy zmiany:

```ts:AppProviders.tsx
export const AppProviders = ({
  children,
}: {
  readonly children: ReactNode;
}) => {
  const [theme, setTheme] = useState<Theme>("dark");
  const [user, setUser] = useState<User>({
    id: 1,
    email: "foo@gmail.com",
  });

  const changeTheme = useCallback((theme: Theme) => setTheme(theme), []);
  const changeUser = useCallback((user: User) => setUser(user), []);

  const themeValue = useMemo(
    () => ({ theme, changeTheme }),
    [theme, changeTheme],
  );

  const userValue = useMemo(() => ({ user, changeUser }), [user, changeUser]);

  return (
    <ThemeContext.Provider value={themeValue}>
      <UserContext.Provider value={userValue}>{children}</UserContext.Provider>
    </ThemeContext.Provider>
  );
};
```

Zauwa偶ye/a co si zmienio w nowym komponencie `AppProviders`? Jak wida, do naszych funkcji oraz wartoci provider贸w doszy **dwa hooki** - `useCallback`, oraz `useMemo`. Jaki to ma cel?

Od teraz React bdzie **cache'owa definicje naszych funkcji oraz obiekt贸w** i dop贸ki **nie zmieni sitablica zale偶noci**, co ka偶dy render otrzymamy **dokadnie t sam referencj, co wywoanie wczeniej**. Jaki to miao wpyw na `useContext`?

Tym razem zmieniajc warto stanu `theme` za pomoc funkcji `changeTheme`, przerenderowanie komponentu spowoduje **zmian referencji tylko i wycznie obiektu `themeValue`**, co za tym idzie - przerenderuj si **tylko i wycznie komponenty korzystajce z jego kontekstu**. Dlaczego?

Do tablicy zale偶noci `themeValue` przekazalimy **dwa obiekty**: `theme`, oraz `changeTheme`. Callback `changeTheme` nie powinien nigdy zmieniswojej referencji, poniewa偶 posiada **pust tablic zale偶noci**. Natomiast wywoujc funkcj `setTheme` **zmutowalimy stan**, co za tym idzie - **zmienilimy warto `theme`**, a wic **`useMemo` w `themeValue` zwr贸ci now referencj**. Poniewa偶 referencja obiektu `themeValue` **ulega zmianie**, `Object.is` zwr贸ci `false`, co za tym idzie - React **musi odwie偶y komponenty korzystajce z kontekstu `ThemeContext`**.

W przypadku obiektu `userValue`, podczas zmiany stanu `theme`, **nie zmienia si 偶adna warto w tablicy zale偶noci**, dlatego **dostajemy za ka偶dym razem t sam referencj**, a React **nie ma powodu, aby przerenderowa komponenty u偶ywajce kontekstu `UserContext`**. W ten spos贸b udowodniem, 偶e por贸wnywanie wartoci `value` **faktycznie odbywa si za pomoc metody `Object.is`**.

Fajnie, wszystko dziaa jak nale偶y, ale czy mo偶emy zrobi to lepiej? Oczywicie - na tworzenie provider贸w znam jeszcze lepszy spos贸b, poka偶 Ci go .

## Wydzielenie ka偶dego providera do osobnego pliku

Zamiast **trzyma stan wszystkich provider贸w w jednym komponencie**, mo偶emy **stworzy komponent ze stanem dla ka偶dego providera osobno**:

<iframe
	src="https://codesandbox.io/embed/wydajne-providery-w-reactjs-4-rx4lqg?expanddevtools=1&fontsize=14&hidenavigation=1&module=%2Fsrc%2Fproviders%2FAppProviders.tsx&theme=dark"
	style={{
		width: '100%',
		height: '500px',
		border: 0,
		borderRadius: '4px',
		overflow: 'hidden',
	}}
	title="wydajne-providery-w-reactjs-4"
	allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
	sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

Wprowadzilimy kilka poprawek, ale zanim si im przyjrzymy, ponownie zacznijmy od skontrolowania sytuacji rerender贸w:

<Image
	src="/posts/wydajne-providery-w-reactjs/preview-4.gif"
	alt="Podgld 4"
	width={1680}
	height={1050}
/>

Tak jak widzimy, nasz kod dalej **zachowuje si w najbardziej optymalny spos贸b**, **odwie偶ajc tylko to, co potrzebne**. Zajrzyjmy wic do rodka i om贸wmy zmiany, kt贸re zaszy:

```ts:AppProviders.tsx
export const AppProviders = ({
  children,
}: {
  readonly children: ReactNode;
}) => (
  <ThemeProvider>
    <UserProvider>{children}</UserProvider>
  </ThemeProvider>
);
```

```ts:ThemeProvider.tsx
export const ThemeProvider = ({
  children,
}: {
  readonly children: ReactNode;
}) => {
  const [theme, setTheme] = useState<Theme>("dark");

  const changeTheme = (theme: Theme) => setTheme(theme);

  return (
    <ThemeContext.Provider value={{ theme, changeTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};
```

```ts:UserProvider.tsx
export const UserProvider = ({
  children,
}: {
  readonly children: ReactNode;
}) => {
  const [user, setUser] = useState<User>({
    id: 1,
    email: "foo@gmail.com",
  });

  const changeUser = (user: User) => setUser(user);

  return (
    <UserContext.Provider value={{ user, changeUser }}>
      {children}
    </UserContext.Provider>
  );
};
```

Z komponentu `AppProviders` **pozbylimy si tony kodu odpowiedzalnego za zarzdzanie stanem dw贸ch provider贸w w naszej aplikacji**. Zosta on **przeniesiony do osobnych komponent贸w**, utworzonych specjalnie pod ka偶dy provider - `ThemeProvider`, oraz `UserProvider`. Jakie mamy zalety? Przede wszystkim **pozbylimy siproblemu z czytelnoci**, o kt贸rym wspomniaem na samym pocztku tego artykuu. Od teraz chcc edytowa dany provider, **nie przebijamy si przez mas logiki pochodzcej z innego providera**. Zamiast tego **udajemy si do osobnego komponentu**, gdzie **wszystko jest adnie uporzdkowane**. Jednoczenie jestemy przygotowani na ewentualno **dodania kolejnych provider贸w w przyszoci**, bez obawy o czytelno kodu.

Bardziej spostrzegawcze osoby zauwa偶yy pewnie, 偶e **przestalimy r贸wnie偶 u偶ywa `useCallback`, oraz `useMemo`**, a mimo wszystko **kod zachowuje si tak, jak tego oczekiwalimy**. Dlaczego tak si dzieje?

Zauwa偶, 偶e od teraz **nie renderujemy 偶adnego komponentu bezporednio w providerach**. Zamiast tego przekazujemy je w propsie `children`. Oznacza to, 偶e renderujc ponownie komponent `ThemeProvider`, **nie spowoduje on przerenderowania komponentu `UserProvider`**, poniewa偶 **go tam nie ma**. Zwracamy tylko obiekt `children`, kt贸ry **zosta utworzony wy偶ej**. Tak wic zmieniajc stan w komponencie `ThemeProvider`, **nie spowoduje on rerenderu `UserProvider`**, co za tym idzie - referencja `value` **nie ulegnie zmianie podczas mutacji tego stanu**, dziki czemu React **nie przerenderuje komponent贸w korzystajcych z contextu `UserContext`**.

Zdecydowanie jest to **najlepsze podejcie z wy偶ej wymienionych**. Dziki niemu nie tylko **zyskalimy na czytelnoci kodu**, ale i **pozbylimy sihook贸w `useCallback` oraz `useMemo`**, co na pewno wpynie pozytywnie na **optymalizacj naszej strony Internetowej**.

## Inny spos贸b na rozwizanie zadania

Zabierajc si za taska z jiry, tak naprawd mo偶emy rozwiza go na jeszcze jeden spos贸b. Celowo pominem to podejcie, 偶eby nie wprowadza zamieszania, dlatego sp贸jrzmy teraz na przykad:

<iframe
	src="https://codesandbox.io/embed/wydajne-providery-w-reactjs-5-cjsx6z?expanddevtools=1&fontsize=14&hidenavigation=1&module=%2Fsrc%2Fproviders%2FAppProvider.tsx&theme=dark"
	style={{
		width: '100%',
		height: '500px',
		border: 0,
		borderRadius: '4px',
		overflow: 'hidden',
	}}
	title="wydajne-providery-w-reactjs-5"
	allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
	sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

Osoby pocztkujce mog **nie wpa na pomys**, 偶eby stworzy **dwa osobne providery** - zamiast tego **utworz jeden wielki provider**, przechowujcy **globalny stan naszej caej aplikacji**. Jest to **powa偶ny bd**, kt贸ry zaraz Ci wytumacz, ale najpierw skontrolujmy rerendery na naszej stronie:

<Image
	src="/posts/wydajne-providery-w-reactjs/preview-5.gif"
	alt="Podgld 5"
	width={1680}
	height={1050}
/>

Ponownie wr贸cilimy do problemu, kt贸ry przez cay czas pr贸bowalimy zwalczy - **rerenderujemy wszystkie komponenty, u偶ywajce hooka `useContext`**. Musz Ci niestety zmartwi - **tutaj nie da si tego naprawi i tym razem nawet memoizacja nam nie pomo偶e** - dlaczego? Sp贸jrzmy na plik `AppProvider.tsx`:

```ts:AppProvider.tsx
export const AppProvider = ({ children }: { readonly children: ReactNode }) => {
  const [theme, setTheme] = useState<Theme>("dark");
  const [user, setUser] = useState<User>({
    id: 1,
    email: "foo@gmail.com",
  });

  const changeTheme = (theme: Theme) => setTheme(theme);
  const changeUser = (user: User) => setUser(user);

  return (
    <AppContext.Provider value={{ theme, user, changeTheme, changeUser }}>
      {children}
    </AppContext.Provider>
  );
};
```

Widzimy, 偶e komponent `AppProvider` odpowiedzialny jest za **przechowywanie globalnego stanu caej naszej aplikacji**. Jaki jest w tym problem?

Tak jak wczeniej wspomniaem, React **analizuje kiedy ma przerenderowa komponenet** za pomocmetody `Object.is`. W tym przypadku wywoanie funkcji `changeTheme` spowoduje wywoanie `setTheme`, co z kolei przeo偶y si na wywoanie funkcji `AppProvider`, czyli wykonamy rerender. Przy nastpnym wywoaniu funkcji **ponownie tworzymy obiekt `{ theme, user, changeTheme, changeUser }`**, wic **dostaje on now referencj**, `Object.is` zwraca `false` i w konsekwencji **dostajemy rerender**. No dobra, to mo偶e znowu spr贸bujemy ugasi po偶ar za pomocmemoizacji?

```ts:AppProvider.tsx
export const AppProvider = ({ children }: { readonly children: ReactNode }) => {
  const [theme, setTheme] = useState<Theme>("dark");
  const [user, setUser] = useState<User>({
    id: 1,
    email: "foo@gmail.com",
  });

  const changeTheme = useCallback((theme: Theme) => setTheme(theme), []);
  const changeUser = useCallback((user: User) => setUser(user), []);

  const value = useMemo(
    () => ({ theme, user, changeTheme, changeUser }),
    [theme, user, changeTheme, changeUser],
  );

  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
};
```

Widzimy, 偶e memoizacja w tym przypadku **nie ma kompletnie 偶adnego sensu**, bo do tablicy zale偶noci przekazujemy `theme`, kt贸ry zmieni si po wywoaniu funkcji `changeTheme`, tak wic obiekt `value` **i tak za ka偶dym razem dostanie now referencj**.

Upraszczajc to co napisaem wy偶ej - **zamiast tworzy jeden ogromny provider, lepiej utworzykilka mniejszych, przechowujcych mae, zgrupowane wartoci**. Dziki temu **unikniemy sytuacji rerenderowania komponent贸w, kt贸re co prawda korzystaj z tego samego kontekstu, ale warto, kt贸rej u偶ywamy si nie zmienia**, wic ten rerender **kompletnie nic nie wnosi i wpyna negatywnie na wydajno**.

**Problem rerenderowania komponent贸w, kt贸rych u偶ywana warto ze stanu nie ulega zmianie** to dosy powszechny temat, dlatego powstao na to kilka rozwiza. Zamiast korzysta z domylnego sposobu na globalny stan w Reacie, mo偶emy **posu偶y sipopularnymi bibliotekami do state managment'u**. Pomocny mo偶e okaza si tutaj chocia偶by [zustand](https://zustand-demo.pmnd.rs/), kt贸ry **trzyma sw贸j stan poza Reactem** i **synchronizuje go za pomoc hooka `useSyncExternalStore`**. Rozwiza on m.in **ten, jak i mas innych problem贸w**, dlatego zainteresowanych odsyam do dokumentacji .

## Podsumowanie

To tyle na dzisiaj. Tym artykuem chciaem rozjani Ci troch, w jaki spos贸b dziaa globalny stan w Reacie, 偶eby m贸g pisa bardziej wiadomy, oraz wydajny kod. Mam nadziej, 偶e wyniose z niego jak cenn lekcj, kt贸r zastosujesz przy codziennej pracy. Zainteresowanych zachcam r贸wnie偶 do podzielenia si swoimi przemyleniami w sekcji komentarzy .
